{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { useLocation, useHistory } from 'react-router';\nimport { getSongData, getArtistData, getRandomSongs, getAlbumData } from '../services/lyrics';\n\nconst useDataResource = () => {\n  _s();\n\n  const [data, setData] = useState(null);\n  const [randomSongs, setRandomSongs] = useState(null);\n  const history = useHistory();\n  const location = useLocation(); // Fetch data according to the type\n\n  const fetchData = async (id, type) => {\n    switch (type) {\n      case 'song':\n        return await getSongData(id);\n\n      case 'album':\n        return await getAlbumData(id);\n\n      case 'artist':\n        return await getArtistData(id);\n\n      default:\n        return null;\n    }\n  }; // On first render fetch 2 random songs to display on home page\n\n\n  useEffect(() => {\n    const handleFetchData = async () => {\n      try {\n        setRandomSongs(await getRandomSongs(2));\n      } catch (error) {}\n    };\n\n    handleFetchData();\n  }, []); // Everytime location changes tries to fetch the data\n\n  const loadData = () => {\n    const handleFetchData = async () => {\n      const [, id, path] = location.pathname.split('/');\n\n      try {\n        setData(await fetchData(path, id));\n      } catch (error) {\n        setData({\n          _type: 'error',\n          content: '404'\n        });\n      }\n    };\n\n    handleFetchData();\n  }; // HandleDataChange to make sure data is being vanished before changing to new path\n\n\n  const handleDataChange = async (id, type) => {\n    setData(null);\n    history.push(`/${type}/${id}`);\n  };\n\n  return [data, randomSongs, handleDataChange, loadData];\n};\n\n_s(useDataResource, \"sMYslw/I0D3aDEY7lquxZXD4zZU=\", false, function () {\n  return [useHistory, useLocation];\n});\n\nexport default useDataResource;","map":{"version":3,"sources":["C:/Users/energ/Documents/GitHub/music-app/client/src/hooks/useDataResource.js"],"names":["useState","useEffect","useLocation","useHistory","getSongData","getArtistData","getRandomSongs","getAlbumData","useDataResource","data","setData","randomSongs","setRandomSongs","history","location","fetchData","id","type","handleFetchData","error","loadData","path","pathname","split","_type","content","handleDataChange","push"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,SAASC,WAAT,EAAsBC,UAAtB,QAAwC,cAAxC;AACA,SAASC,WAAT,EAAsBC,aAAtB,EAAqCC,cAArC,EAAqDC,YAArD,QAAyE,oBAAzE;;AAEA,MAAMC,eAAe,GAAG,MAAM;AAAA;;AAC5B,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBV,QAAQ,CAAC,IAAD,CAAhC;AACA,QAAM,CAACW,WAAD,EAAcC,cAAd,IAAgCZ,QAAQ,CAAC,IAAD,CAA9C;AAEA,QAAMa,OAAO,GAAGV,UAAU,EAA1B;AACA,QAAMW,QAAQ,GAAGZ,WAAW,EAA5B,CAL4B,CAO5B;;AACA,QAAMa,SAAS,GAAG,OAAOC,EAAP,EAAWC,IAAX,KAAoB;AACpC,YAAOA,IAAP;AACE,WAAK,MAAL;AACE,eAAO,MAAMb,WAAW,CAACY,EAAD,CAAxB;;AACF,WAAK,OAAL;AACE,eAAO,MAAMT,YAAY,CAACS,EAAD,CAAzB;;AACF,WAAK,QAAL;AACE,eAAO,MAAMX,aAAa,CAACW,EAAD,CAA1B;;AACF;AACE,eAAO,IAAP;AARJ;AAUD,GAXD,CAR4B,CAqB5B;;;AACAf,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMiB,eAAe,GAAG,YAAY;AAClC,UAAI;AACFN,QAAAA,cAAc,CAAC,MAAMN,cAAc,CAAC,CAAD,CAArB,CAAd;AACD,OAFD,CAEE,OAAOa,KAAP,EAAc,CAAE;AACnB,KAJD;;AAMAD,IAAAA,eAAe;AAChB,GARQ,EAQN,EARM,CAAT,CAtB4B,CAgC5B;;AACA,QAAME,QAAQ,GAAG,MAAM;AACrB,UAAMF,eAAe,GAAG,YAAY;AAClC,YAAM,GAAGF,EAAH,EAAOK,IAAP,IAAeP,QAAQ,CAACQ,QAAT,CAAkBC,KAAlB,CAAwB,GAAxB,CAArB;;AAEA,UAAI;AACFb,QAAAA,OAAO,CAAC,MAAMK,SAAS,CAACM,IAAD,EAAOL,EAAP,CAAhB,CAAP;AACD,OAFD,CAEE,OAAOG,KAAP,EAAc;AACdT,QAAAA,OAAO,CAAC;AAAEc,UAAAA,KAAK,EAAE,OAAT;AAAkBC,UAAAA,OAAO,EAAE;AAA3B,SAAD,CAAP;AACD;AACF,KARD;;AAUAP,IAAAA,eAAe;AAChB,GAZD,CAjC4B,CA+C5B;;;AACA,QAAMQ,gBAAgB,GAAG,OAAOV,EAAP,EAAWC,IAAX,KAAoB;AAC3CP,IAAAA,OAAO,CAAC,IAAD,CAAP;AACAG,IAAAA,OAAO,CAACc,IAAR,CAAc,IAAGV,IAAK,IAAGD,EAAG,EAA5B;AACD,GAHD;;AAKA,SAAO,CACLP,IADK,EACCE,WADD,EACce,gBADd,EACgCN,QADhC,CAAP;AAGD,CAxDD;;GAAMZ,e;UAIYL,U,EACCD,W;;;AAqDnB,eAAeM,eAAf","sourcesContent":["import { useState, useEffect } from 'react'\r\nimport { useLocation, useHistory } from 'react-router'\r\nimport { getSongData, getArtistData, getRandomSongs, getAlbumData } from '../services/lyrics'\r\n\r\nconst useDataResource = () => {\r\n  const [data, setData] = useState(null)\r\n  const [randomSongs, setRandomSongs] = useState(null)\r\n  \r\n  const history = useHistory()\r\n  const location = useLocation()\r\n\r\n  // Fetch data according to the type\r\n  const fetchData = async (id, type) => {\r\n    switch(type) {\r\n      case 'song':\r\n        return await getSongData(id)\r\n      case 'album':\r\n        return await getAlbumData(id)\r\n      case 'artist':\r\n        return await getArtistData(id)\r\n      default:\r\n        return null\r\n    }\r\n  }\r\n\r\n  // On first render fetch 2 random songs to display on home page\r\n  useEffect(() => {\r\n    const handleFetchData = async () => {\r\n      try {\r\n        setRandomSongs(await getRandomSongs(2))\r\n      } catch (error) {}\r\n    }\r\n    \r\n    handleFetchData()\r\n  }, [])\r\n  \r\n  // Everytime location changes tries to fetch the data\r\n  const loadData = () => {\r\n    const handleFetchData = async () => {\r\n      const [, id, path] = location.pathname.split('/')\r\n\r\n      try {\r\n        setData(await fetchData(path, id))\r\n      } catch (error) {\r\n        setData({ _type: 'error', content: '404' })\r\n      }\r\n    }\r\n\r\n    handleFetchData()\r\n  }\r\n\r\n  // HandleDataChange to make sure data is being vanished before changing to new path\r\n  const handleDataChange = async (id, type) => {\r\n    setData(null)\r\n    history.push(`/${type}/${id}`)\r\n  }\r\n\r\n  return [\r\n    data, randomSongs, handleDataChange, loadData\r\n  ]\r\n}\r\n\r\nexport default useDataResource"]},"metadata":{},"sourceType":"module"}