{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { useLocation, useHistory } from 'react-router';\nimport { getSongData, getArtistData, getRandomSongs } from '../services/lyrics';\n\nconst useDataResource = () => {\n  _s();\n\n  const [data, setData] = useState(null);\n  const [randomSongs, setRandomSongs] = useState(null);\n  const history = useHistory();\n  const location = useLocation(); // Fetch data according to the type\n\n  const fetchData = async (id, type) => {\n    switch (type) {\n      case 'song':\n        return await getSongData(id);\n\n      case 'artist':\n        return await getArtistData(id);\n\n      default:\n        return null;\n    }\n  }; // On first render fetch 2 random songs to display on home page\n\n\n  useEffect(() => {\n    const handleFetchData = async () => {\n      try {\n        setRandomSongs(await getRandomSongs(2));\n      } catch (error) {}\n    };\n\n    handleFetchData();\n  }, []); // Everytime location changes tries to fetch the data\n\n  useEffect(() => {\n    const handleFetchData = async () => {\n      const [, id, path] = location.pathname.split('/');\n\n      try {\n        setData(await fetchData(path, id));\n      } catch (error) {\n        setData({\n          _type: 'error',\n          content: '404'\n        });\n      }\n    };\n\n    handleFetchData();\n  }, [location]); // HandleDataChange to make sure data is being vanished before changing to new path\n\n  const handleDataChange = async (id, type) => {\n    setData(null);\n    history.push(`/${type}/${id}`);\n  };\n\n  return [data, randomSongs, handleDataChange];\n};\n\n_s(useDataResource, \"wemH2hGp1F0KJUAOWOM5Oi3dAC4=\", false, function () {\n  return [useHistory, useLocation];\n});\n\nexport default useDataResource;","map":{"version":3,"sources":["C:/Users/energ/Documents/GitHub/music-app/client/src/hooks/useDataResource.js"],"names":["useState","useEffect","useLocation","useHistory","getSongData","getArtistData","getRandomSongs","useDataResource","data","setData","randomSongs","setRandomSongs","history","location","fetchData","id","type","handleFetchData","error","path","pathname","split","_type","content","handleDataChange","push"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,SAASC,WAAT,EAAsBC,UAAtB,QAAwC,cAAxC;AACA,SAASC,WAAT,EAAsBC,aAAtB,EAAqCC,cAArC,QAA2D,oBAA3D;;AAEA,MAAMC,eAAe,GAAG,MAAM;AAAA;;AAC5B,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBT,QAAQ,CAAC,IAAD,CAAhC;AACA,QAAM,CAACU,WAAD,EAAcC,cAAd,IAAgCX,QAAQ,CAAC,IAAD,CAA9C;AAEA,QAAMY,OAAO,GAAGT,UAAU,EAA1B;AACA,QAAMU,QAAQ,GAAGX,WAAW,EAA5B,CAL4B,CAO5B;;AACA,QAAMY,SAAS,GAAG,OAAOC,EAAP,EAAWC,IAAX,KAAoB;AACpC,YAAOA,IAAP;AACE,WAAK,MAAL;AACE,eAAO,MAAMZ,WAAW,CAACW,EAAD,CAAxB;;AACF,WAAK,QAAL;AACE,eAAO,MAAMV,aAAa,CAACU,EAAD,CAA1B;;AACF;AACE,eAAO,IAAP;AANJ;AAQD,GATD,CAR4B,CAmB5B;;;AACAd,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMgB,eAAe,GAAG,YAAY;AAClC,UAAI;AACFN,QAAAA,cAAc,CAAC,MAAML,cAAc,CAAC,CAAD,CAArB,CAAd;AACD,OAFD,CAEE,OAAOY,KAAP,EAAc,CAAE;AACnB,KAJD;;AAMAD,IAAAA,eAAe;AAChB,GARQ,EAQN,EARM,CAAT,CApB4B,CA8B5B;;AACAhB,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMgB,eAAe,GAAG,YAAY;AAClC,YAAM,GAAGF,EAAH,EAAOI,IAAP,IAAeN,QAAQ,CAACO,QAAT,CAAkBC,KAAlB,CAAwB,GAAxB,CAArB;;AAEA,UAAI;AACFZ,QAAAA,OAAO,CAAC,MAAMK,SAAS,CAACK,IAAD,EAAOJ,EAAP,CAAhB,CAAP;AACD,OAFD,CAEE,OAAOG,KAAP,EAAc;AACdT,QAAAA,OAAO,CAAC;AAAEa,UAAAA,KAAK,EAAE,OAAT;AAAkBC,UAAAA,OAAO,EAAE;AAA3B,SAAD,CAAP;AACD;AACF,KARD;;AAUAN,IAAAA,eAAe;AAChB,GAZQ,EAYN,CAACJ,QAAD,CAZM,CAAT,CA/B4B,CA6C5B;;AACA,QAAMW,gBAAgB,GAAG,OAAOT,EAAP,EAAWC,IAAX,KAAoB;AAC3CP,IAAAA,OAAO,CAAC,IAAD,CAAP;AACAG,IAAAA,OAAO,CAACa,IAAR,CAAc,IAAGT,IAAK,IAAGD,EAAG,EAA5B;AACD,GAHD;;AAKA,SAAO,CACLP,IADK,EACCE,WADD,EACcc,gBADd,CAAP;AAGD,CAtDD;;GAAMjB,e;UAIYJ,U,EACCD,W;;;AAmDnB,eAAeK,eAAf","sourcesContent":["import { useState, useEffect } from 'react'\r\nimport { useLocation, useHistory } from 'react-router'\r\nimport { getSongData, getArtistData, getRandomSongs } from '../services/lyrics'\r\n\r\nconst useDataResource = () => {\r\n  const [data, setData] = useState(null)\r\n  const [randomSongs, setRandomSongs] = useState(null)\r\n  \r\n  const history = useHistory()\r\n  const location = useLocation()\r\n\r\n  // Fetch data according to the type\r\n  const fetchData = async (id, type) => {\r\n    switch(type) {\r\n      case 'song':\r\n        return await getSongData(id)\r\n      case 'artist':\r\n        return await getArtistData(id)\r\n      default:\r\n        return null\r\n    }\r\n  }\r\n\r\n  // On first render fetch 2 random songs to display on home page\r\n  useEffect(() => {\r\n    const handleFetchData = async () => {\r\n      try {\r\n        setRandomSongs(await getRandomSongs(2))\r\n      } catch (error) {}\r\n    }\r\n    \r\n    handleFetchData()\r\n  }, [])\r\n  \r\n  // Everytime location changes tries to fetch the data\r\n  useEffect(() => {\r\n    const handleFetchData = async () => {\r\n      const [, id, path] = location.pathname.split('/')\r\n\r\n      try {\r\n        setData(await fetchData(path, id))\r\n      } catch (error) {\r\n        setData({ _type: 'error', content: '404' })\r\n      }\r\n    }\r\n\r\n    handleFetchData()\r\n  }, [location])\r\n\r\n  // HandleDataChange to make sure data is being vanished before changing to new path\r\n  const handleDataChange = async (id, type) => {\r\n    setData(null)\r\n    history.push(`/${type}/${id}`)\r\n  }\r\n\r\n  return [\r\n    data, randomSongs, handleDataChange\r\n  ]\r\n}\r\n\r\nexport default useDataResource"]},"metadata":{},"sourceType":"module"}